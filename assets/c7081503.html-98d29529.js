import{_ as t,o as r,c as d,e}from"./app-5de3c553.js";const a={},n=e('<figure class="highlight java"><figcaption data-lang="java"></figcaption><div class="code-container"><table><tr><td data-num="1"></td><td><pre>/**</pre></td></tr><tr><td data-num="2"></td><td><pre> * Definition for a binary tree node.</pre></td></tr><tr><td data-num="3"></td><td><pre> * public class TreeNode {</pre></td></tr><tr><td data-num="4"></td><td><pre> *     int val;</pre></td></tr><tr><td data-num="5"></td><td><pre> *     TreeNode left;</pre></td></tr><tr><td data-num="6"></td><td><pre> *     TreeNode right;</pre></td></tr><tr><td data-num="7"></td><td><pre> *     TreeNode() {}</pre></td></tr><tr><td data-num="8"></td><td><pre> *     TreeNode(int val) { this.val = val; }</pre></td></tr><tr><td data-num="9"></td><td><pre> *     TreeNode(int val, TreeNode left, TreeNode right) {</pre></td></tr><tr><td data-num="10"></td><td><pre> *         this.val = val;</pre></td></tr><tr><td data-num="11"></td><td><pre> *         this.left = left;</pre></td></tr><tr><td data-num="12"></td><td><pre> *         this.right = right;</pre></td></tr><tr><td data-num="13"></td><td><pre> *     }</pre></td></tr><tr><td data-num="14"></td><td><pre> * }</pre></td></tr><tr><td data-num="15"></td><td><pre> */</pre></td></tr><tr><td data-num="16"></td><td><pre>class Solution {</pre></td></tr><tr><td data-num="17"></td><td><pre>  public TreeNode buildTree(int[] preorder, int[] inorder) {</pre></td></tr><tr><td data-num="18"></td><td><pre>    return buildTree(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);</pre></td></tr><tr><td data-num="19"></td><td><pre>  }</pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>  private TreeNode buildTree(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd) {</pre></td></tr><tr><td data-num="22"></td><td><pre>    if (preStart &gt; preEnd) {</pre></td></tr><tr><td data-num="23"></td><td><pre>      return null;</pre></td></tr><tr><td data-num="24"></td><td><pre>    }   //根的值</pre></td></tr><tr><td data-num="25"></td><td><pre>    int rootVal = preorder[preStart];</pre></td></tr><tr><td data-num="26"></td><td><pre>    //中序中根的位置</pre></td></tr><tr><td data-num="27"></td><td><pre>    int index = 0;</pre></td></tr><tr><td data-num="28"></td><td><pre>    for (int i = inStart; i &lt;= inEnd; i++) {</pre></td></tr><tr><td data-num="29"></td><td><pre>      if (inorder[i] == rootVal) {</pre></td></tr><tr><td data-num="30"></td><td><pre>        index = i;</pre></td></tr><tr><td data-num="31"></td><td><pre>        break;</pre></td></tr><tr><td data-num="32"></td><td><pre>      }</pre></td></tr><tr><td data-num="33"></td><td><pre>    }</pre></td></tr><tr><td data-num="34"></td><td><pre>    //根节点左边节点数</pre></td></tr><tr><td data-num="35"></td><td><pre>    int leftSize = index - inStart;</pre></td></tr><tr><td data-num="36"></td><td><pre>    TreeNode root = new TreeNode(rootVal);</pre></td></tr><tr><td data-num="37"></td><td><pre>    //[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</pre></td></tr><tr><td data-num="38"></td><td><pre>    //[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</pre></td></tr><tr><td data-num="39"></td><td><pre>    root.left = buildTree(preorder, inorder, preStart + 1, preStart + leftSize, inStart, index - 1);</pre></td></tr><tr><td data-num="40"></td><td><pre>    root.right = buildTree(preorder, inorder, preStart + 1 + leftSize, preEnd, index + 1, inEnd);</pre></td></tr><tr><td data-num="41"></td><td><pre>    return root;</pre></td></tr><tr><td data-num="42"></td><td><pre>  }</pre></td></tr><tr><td data-num="43"></td><td><pre>}</pre></td></tr></table><div class="operation"><span class="breakline-btn"><i class="ic i-align-left"></i></span><span class="copy-btn"><i class="ic i-clipboard"></i></span><span class="fullscreen-btn"><i class="ic i-expand"></i></span></div></div></figure><p>改进</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><div class="code-container"><table><tr><td data-num="1"></td><td><pre>class Solution {</pre></td></tr><tr><td data-num="2"></td><td><pre>  Map&lt;Integer,Integer&gt; valOrderMap = new HashMap&lt;&gt;();</pre></td></tr><tr><td data-num="3"></td><td><pre>  public TreeNode buildTree(int[] preorder, int[] inorder) {</pre></td></tr><tr><td data-num="4"></td><td><pre>    for (int j = 0; j &lt; inorder.length; j++) {</pre></td></tr><tr><td data-num="5"></td><td><pre>      valOrderMap.put(inorder[j],j);</pre></td></tr><tr><td data-num="6"></td><td><pre>    }</pre></td></tr><tr><td data-num="7"></td><td><pre>    return buildTree(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);</pre></td></tr><tr><td data-num="8"></td><td><pre>  }</pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  private TreeNode buildTree(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd) {</pre></td></tr><tr><td data-num="11"></td><td><pre>    if (preStart &gt; preEnd) {</pre></td></tr><tr><td data-num="12"></td><td><pre>      return null;</pre></td></tr><tr><td data-num="13"></td><td><pre>    }   //根的值</pre></td></tr><tr><td data-num="14"></td><td><pre>    int rootVal = preorder[preStart];</pre></td></tr><tr><td data-num="15"></td><td><pre>    //中序中根的位置</pre></td></tr><tr><td data-num="16"></td><td><pre>    int index = valOrderMap.get(rootVal);</pre></td></tr><tr><td data-num="17"></td><td><pre>    //根节点左边节点数</pre></td></tr><tr><td data-num="18"></td><td><pre>    int leftSize = index - inStart;</pre></td></tr><tr><td data-num="19"></td><td><pre>    TreeNode root = new TreeNode(rootVal);</pre></td></tr><tr><td data-num="20"></td><td><pre>    //[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</pre></td></tr><tr><td data-num="21"></td><td><pre>    //[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</pre></td></tr><tr><td data-num="22"></td><td><pre>    root.left = buildTree(preorder, inorder, preStart + 1, preStart + leftSize, inStart, index - 1);</pre></td></tr><tr><td data-num="23"></td><td><pre>    root.right = buildTree(preorder, inorder, preStart + 1 + leftSize, preEnd, index + 1, inEnd);</pre></td></tr><tr><td data-num="24"></td><td><pre>    return root;</pre></td></tr><tr><td data-num="25"></td><td><pre>  }</pre></td></tr><tr><td data-num="26"></td><td><pre>}</pre></td></tr></table><div class="operation"><span class="breakline-btn"><i class="ic i-align-left"></i></span><span class="copy-btn"><i class="ic i-clipboard"></i></span><span class="fullscreen-btn"><i class="ic i-expand"></i></span></div></div></figure>',3),p=[n];function i(o,l){return r(),d("div",null,p)}const m=t(a,[["render",i],["__file","c7081503.html.vue"]]);export{m as default};
