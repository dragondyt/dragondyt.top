const t=JSON.parse('{"key":"v-8daa1a0e","path":"/","title":"首页","lang":"en-US","frontmatter":{"gen":true,"title":"首页","layout":"IndexLayout","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Organization\\",\\"url\\":\\"https://dragondyt.top\\",\\"logo\\":\\"https://dragondyt.top/logo.png\\"}"],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebSite\\",\\"url\\":\\"https://blog.dragondyt.top\\",\\"potentialAction\\":{\\"@type\\":\\"SearchAction\\",\\"target\\":{\\"@type\\":\\"EntryPoint\\",\\"urlTemplate\\":\\"https://blog.dragondyt.top/search?q={search_term_string}\\"},\\"query-input\\":\\"required name=search_term_string\\"}}"],["link",{"rel":"alternate","type":"application/rss+xml","href":"https://blog.dragondyt.top/rss.xml","title":"RSS"}],["link",{"rel":"alternate","type":"application/json","href":"https://blog.dragondyt.top/feed.json","title":"RSS"}],["link",{"rel":"alternate","type":"application/atom+xml","href":"https://blog.dragondyt.top/atom.xml","title":"RSS"}],["link",{"rel":"amphtml","href":"/index.amp.html"}]],"current":1,"prev":0,"next":2,"total":4,"mid_size":1,"end_size":1,"space":"...","base":"/","pagePostList":[{"path":"/8612fa7f/b7e144d1/340249a9/76a66db0.html","title":"[2073]买票需要的时间","date":"2022-08-04","description":"class Solution { public int timeRequiredToBuy(int[] tickets, int k) { int ret = 0; for (int i = 0; i &amp;lt; tickets.length; i++) { if (i &amp;lt;= k) { ret = ret + Math.min(tickets[i], tickets[k]); } else { ret = ret + Math.min(tickets[i], tickets[k] - 1); } } return ret; }}","symbolsCount":"579 ","symbolsTime":"1","category":{"path":"/categories/11159622/b7e144d1/e85d694a/","name":"二叉树"}},{"path":"/8612fa7f/b7e144d1/2362a8ea/389d18c2.html","title":"[160]相交链表","date":"2022-08-04","description":"public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // p1 指向 A 链表头结点，p2 指向 B 链表头结点 ListNode p1 = headA, p2 = headB; while (p1 != p2) { // p1 走一步，如果走到 A 链表末尾，转到 B 链表 if (p1 == null) { p1 = headB; } else { p1 = p1.next; } // p2 走一步，如果走到 B 链表末尾，转到 A 链表 if (p2...","symbolsCount":"671 ","symbolsTime":"1","category":{"path":"/categories/11159622/b7e144d1/2362a8ea/","name":"链表"}},{"path":"/8612fa7f/b7e144d1/2362a8ea/69a9925d.html","title":"[141]环形链表","date":"2022-08-03","description":"/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head, slow = head; // 快指针走到末尾时停止 while (fast != null &amp;amp;&amp;amp;...","symbolsCount":"722 ","symbolsTime":"1","category":{"path":"/categories/11159622/b7e144d1/2362a8ea/","name":"链表"}},{"path":"/8612fa7f/b7e144d1/2362a8ea/36462e02.html","title":"[19]删除链表的倒数第 N 个结点","date":"2022-08-03","description":"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode removeNthFromEnd(ListNode head, int...","symbolsCount":"1k","symbolsTime":"1","category":{"path":"/categories/11159622/b7e144d1/2362a8ea/","name":"链表"}},{"path":"/8612fa7f/b7e144d1/2362a8ea/6d80ff7f.html","title":"[876]链表的中间结点","date":"2022-08-03","description":"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode middleNode(ListNode head) {...","symbolsCount":"815 ","symbolsTime":"1","category":{"path":"/categories/11159622/b7e144d1/2362a8ea/","name":"链表"}},{"path":"/8612fa7f/b7e144d1/2362a8ea/9862a150.html","title":"[剑指 Offer II 022]链表中环的入口节点","date":"2022-08-03","description":"/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode detectCycle(ListNode head) { //如果用两个指针 ListNode fast = head, slow = head; while (fast != null &amp;amp;&amp;amp;...","symbolsCount":"838 ","symbolsTime":"1","category":{}},{"path":"/8612fa7f/b7e144d1/2362a8ea/2a1f0504.html","title":"[21]合并两个有序链表","date":"2022-07-28","description":"class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { // 虚拟头结点 ListNode dummy = new ListNode(-1), p = dummy; ListNode p1 = l1, p2 = l2; while (p1 != null &amp;amp;&amp;amp; p2 != null) { // 比较 p1 和 p2 两个指针 // 将值较小的的节点接到 p 指针 if (p1.val &amp;gt; p2.val) { p.next = p2; p2 =...","symbolsCount":"821 ","symbolsTime":"1","category":{"path":"/categories/11159622/b7e144d1/2362a8ea/","name":"链表"}},{"path":"/8612fa7f/b7e144d1/2362a8ea/2cf49dc6.html","title":"[23]合并K个升序链表","date":"2022-07-28","description":"class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) return null; // 虚拟头结点 ListNode dummy = new ListNode(-1); ListNode p = dummy; // 优先级队列，最小堆 PriorityQueue&amp;lt;ListNode&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;( lists.length, (a, b)-&amp;gt;(a.val -...","symbolsCount":"862 ","symbolsTime":"1","category":{"path":"/categories/11159622/b7e144d1/2362a8ea/","name":"链表"}},{"path":"/8612fa7f/b7e144d1/2362a8ea/3758805c.html","title":"[86]分隔链表","date":"2022-07-28","description":"class Solution { public ListNode partition(ListNode head, int x) { // 存放小于 x 的链表的虚拟头结点 ListNode dummy1 = new ListNode(-1); // 存放大于等于 x 的链表的虚拟头结点 ListNode dummy2 = new ListNode(-1); // p1, p2 指针负责生成结果链表 ListNode p1 = dummy1, p2 = dummy2; // p 负责遍历原链表，类似合并两个有序链表的逻辑 // 这里是将一个链表分解成两个链表 ListNode p =...","symbolsCount":"918 ","symbolsTime":"1","category":{"path":"/categories/11159622/b7e144d1/2362a8ea/","name":"链表"}},{"path":"/8612fa7f/b7e144d1/2362a8ea/8f835b6d.html","title":"[剑指 Offer 22]链表中倒数第k个节点","date":"2022-07-28","description":"class Solution { public ListNode getKthFromEnd(ListNode head, int k) { ListNode p1 = head; // p1 先走 k 步 for (int i = 0; i &amp;lt; k; i++) { p1 = p1.next; } ListNode p2 = head; // p1 和 p2 同时走 n - k 步 while (p1 != null) { p2 = p2.next; p1 = p1.next; } // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点 return p2;...","symbolsCount":"628 ","symbolsTime":"1","category":{"path":"/categories/11159622/b7e144d1/2362a8ea/","name":"链表"}}],"stickyPostList":[{"path":"/computer-science/note/79abcd0d.html","title":"Hexo主题Shoka & multi-markdown-it渲染器使用说明","date":"2020-08-13","description":"跳票N久终于更新的简单的使用说明\\n\\nhexo-theme-shoka ：本博客自用的主题\\nhexo-renderer-multi-markdown-it：配套的markdown渲染器\\n\\n已经支持hexo...","symbolsCount":"4k","symbolsTime":"4","category":{"path":"/categories/11159622/97a3d3dd/Theme-Shoka-Documentation/","name":"Theme Shoka Documentation"}}],"catlist":[]},"headers":[]}');export{t as data};
