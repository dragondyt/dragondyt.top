import{_ as t,o as r,c as d,e}from"./app-5de3c553.js";const a={},n=e('<figure class="highlight java"><figcaption data-lang="java"></figcaption><div class="code-container"><table><tr><td data-num="1"></td><td><pre>class Solution {</pre></td></tr><tr><td data-num="2"></td><td><pre>  int rank,res = 0;</pre></td></tr><tr><td data-num="3"></td><td><pre>  public int kthSmallest(TreeNode root, int k) {</pre></td></tr><tr><td data-num="4"></td><td><pre>    traverse(root,k);</pre></td></tr><tr><td data-num="5"></td><td><pre>    return res;</pre></td></tr><tr><td data-num="6"></td><td><pre>  }</pre></td></tr><tr><td data-num="7"></td><td><pre>  private void traverse(TreeNode root, int k) {</pre></td></tr><tr><td data-num="8"></td><td><pre>    if (root == null) {</pre></td></tr><tr><td data-num="9"></td><td><pre>      return;</pre></td></tr><tr><td data-num="10"></td><td><pre>    }</pre></td></tr><tr><td data-num="11"></td><td><pre>    traverse(root.left,k);</pre></td></tr><tr><td data-num="12"></td><td><pre>    //二叉搜索树的特点，若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值，因此先序遍历的就是第k小</pre></td></tr><tr><td data-num="13"></td><td><pre>    rank++;</pre></td></tr><tr><td data-num="14"></td><td><pre>    if (k == rank) {</pre></td></tr><tr><td data-num="15"></td><td><pre>      res = root.val;</pre></td></tr><tr><td data-num="16"></td><td><pre>      return;</pre></td></tr><tr><td data-num="17"></td><td><pre>    }</pre></td></tr><tr><td data-num="18"></td><td><pre>    traverse(root.right,k);</pre></td></tr><tr><td data-num="19"></td><td><pre>  }</pre></td></tr><tr><td data-num="20"></td><td><pre>}</pre></td></tr></table><div class="operation"><span class="breakline-btn"><i class="ic i-align-left"></i></span><span class="copy-btn"><i class="ic i-clipboard"></i></span><span class="fullscreen-btn"><i class="ic i-expand"></i></span></div></div></figure>',1),p=[n];function s(i,o){return r(),d("div",null,p)}const l=t(a,[["render",s],["__file","77c5fdb1.html.vue"]]);export{l as default};
