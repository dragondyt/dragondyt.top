import{_ as t,o as d,c as r,e}from"./app-5de3c553.js";const a={},n=e('<figure class="highlight java"><figcaption data-lang="java"></figcaption><div class="code-container"><table><tr><td data-num="1"></td><td><pre>/**</pre></td></tr><tr><td data-num="2"></td><td><pre> * Definition for singly-linked list.</pre></td></tr><tr><td data-num="3"></td><td><pre> * public class ListNode {</pre></td></tr><tr><td data-num="4"></td><td><pre> *     int val;</pre></td></tr><tr><td data-num="5"></td><td><pre> *     ListNode next;</pre></td></tr><tr><td data-num="6"></td><td><pre> *     ListNode() {}</pre></td></tr><tr><td data-num="7"></td><td><pre> *     ListNode(int val) { this.val = val; }</pre></td></tr><tr><td data-num="8"></td><td><pre> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</pre></td></tr><tr><td data-num="9"></td><td><pre> * }</pre></td></tr><tr><td data-num="10"></td><td><pre> */</pre></td></tr><tr><td data-num="11"></td><td><pre>class Solution {</pre></td></tr><tr><td data-num="12"></td><td><pre>  public ListNode removeNthFromEnd(ListNode head, int n) {</pre></td></tr><tr><td data-num="13"></td><td><pre>    //删除倒数第N个,那我怎么知道N的位置,链表长度不是固定的</pre></td></tr><tr><td data-num="14"></td><td><pre>    //假设是1到x,那么第倒数第N个应该是 X - N + 1</pre></td></tr><tr><td data-num="15"></td><td><pre>    //Y = X - N + 1 ,则</pre></td></tr><tr><td data-num="16"></td><td><pre>    // 虚拟头结点</pre></td></tr><tr><td data-num="17"></td><td><pre>    ListNode pre = new ListNode(0);</pre></td></tr><tr><td data-num="18"></td><td><pre>    pre.next = head;</pre></td></tr><tr><td data-num="19"></td><td><pre>    ListNode start = pre, end = pre;</pre></td></tr><tr><td data-num="20"></td><td><pre>    // p1 先走 n 步</pre></td></tr><tr><td data-num="21"></td><td><pre>    while (n != 0) {</pre></td></tr><tr><td data-num="22"></td><td><pre>      start = start.next;</pre></td></tr><tr><td data-num="23"></td><td><pre>      n--;</pre></td></tr><tr><td data-num="24"></td><td><pre>    }</pre></td></tr><tr><td data-num="25"></td><td><pre>    // p1 和 p2 同时走 x - n 步,当p1走完时，p2走了 x-n步，停在X - N + 1上</pre></td></tr><tr><td data-num="26"></td><td><pre>    while (start.next != null) {</pre></td></tr><tr><td data-num="27"></td><td><pre>      start = start.next;</pre></td></tr><tr><td data-num="28"></td><td><pre>      end = end.next;</pre></td></tr><tr><td data-num="29"></td><td><pre>    }</pre></td></tr><tr><td data-num="30"></td><td><pre>    end.next = end.next.next;</pre></td></tr><tr><td data-num="31"></td><td><pre>    return pre.next;</pre></td></tr><tr><td data-num="32"></td><td><pre>  }</pre></td></tr><tr><td data-num="33"></td><td><pre>}</pre></td></tr></table><div class="operation"><span class="breakline-btn"><i class="ic i-align-left"></i></span><span class="copy-btn"><i class="ic i-clipboard"></i></span><span class="fullscreen-btn"><i class="ic i-expand"></i></span></div></div></figure>',1),p=[n];function i(s,l){return d(),r("div",null,p)}const m=t(a,[["render",i],["__file","36462e02.html.vue"]]);export{m as default};
